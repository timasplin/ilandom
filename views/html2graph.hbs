<!--   <script src="javascripts/recurseDomChildren.js"></script>
 -->  <script src="javascripts/sigma.min.js"></script>
  <script src="javascripts/sigma.layout.forceAtlas2.min.js"></script>
  <script src="javascripts/sigma.layout.noverlap.min.js"></script>
  <script src="javascripts/sigma.plugins.animate.min.js"></script>
  <script>
      window.windowDom = {{{data}}};
  </script>
    <div class="html2graph-info">
        <h3>{{{hud}}}</h3>
        <div>
            <h4>Status</h4>
            <p id="html2graph-status">Started ForceAtlas2</p>
        </div>
    </div>
    <div id="container">
        <style>
        .html2graph-info {
            position: absolute;
        }
        #html2graph-status {
            display: inline-block;
            padding: 5px;
            border-radius: 25px;
            border: 2px solid #73AD21;
            color: #000;
            background-color: white;
            transition: color 1s ease-out, background-color 0.5s ease-out;
            -ms-transition: color 1s ease-out, background-color 0.5s ease-out;
            -moz-transition: color 1s ease-out, background-color 0.5s ease-out;
            -webkit-transition: color 1s ease-out, background-color 0.5s ease-out;
        }
        #html2graph-status.sent-message {
            background-color: yellow;
            color: red;
            transition: color 0.1s ease-in, background-color 0.1s ease-in;
            -ms-transition: color 0.1s ease-in, background-color 0.1s ease-in;
            -moz-transition: color 0.1s ease-in, background-color 0.1s ease-in;
            -webkit-transition: color 0.1s ease-in, background-color 0.1s ease-in;
        }
        #graph-container {
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
            position: absolute;
        }
        </style>
        <div id="graph-container"></div>
    </div>
    <script>
    /**
     * Html2Graph will create a force directed graph of a DOM object, or any object that has the following structure:
     {
        "nodeType": @int,
        "nodeName": @string,
        "nodeValue": @string,
        "childNodes": @array[] or empty
     }
     The nodeValue object text should always arrive here escaped, so <script> tags will not be written from other DOM objects, in the client.
     */

    var s,
        nodeIdPrefix = 'n',
        edgeIdPrefix = 'e',
        nodeSize = 15,
        nodeColor = '#' + (
            Math.floor(Math.random() * 16777215).toString(16) + '000000'
        ).substr(0, 6),
        forceAtlas2Config,
        SEC = 1000,
        finaleEaseTime = 5 * SEC;
        stepTime = 0.1 * SEC;

    s = new sigma({
      container: 'graph-container',
      settings: {
          drawNodes: false,
          minEdgeSize: 0.1,
          maxEdgeSize: 0.1
      }
    });

    forceAtlas2Config = {
        linLogMode: false,
        outboundAttractionDistribution: false,
        adjustSizes: false, //true works weirdly... like the gravity moves around
        worker: true,
        barnesHutOptimize: false,
        slowDown: 10,
        gravity: 2, //keeps things in the center
        scalingRatio: 1,
        edgeWeightInfluence: 0, //setting to 1 makes things less free
        startingIterations: 1,
        iterationsPerRender: 1,
        strongGravityMode: false //that one makes things stickier
    };

    //var edgeIntervalId = setInterval(addAnEdge, 0.3*SEC, E*2);
    //var nodeIntervalId = setInterval(addNodesToEnd, 0.1*SEC, 100);

    /*
     * Breadth First
     */
    recurseBF(s, getHtmlNode(window.windowDom));

    /*
     * Depth First, all children first
     */
    // var rootId = createRoot(s, window.windowDom);
    // recurseDomChildren(s, window.windowDom, rootId);
    // //TODO: this is not stopping it...
    // setTimeout(function() {
    //     s.killForceAtlas2();
    //     console.log('Stopped ForceAtlas2');
    //     updateStatus('Stopped ForceAtlas2');
    //     //doNoverlap(graphInstance);
    // }, finaleEaseTime);



    // ----------- Lib ---------------
    function getHtmlNode (domObject) {
        var i = 0;
        var htmlNode = domObject;

        // Get the first node of type 1
        while ( htmlNode.nodeType !== 1) {
            htmlNode = domObject.childNodes[++i];
        }

        return htmlNode;
    }

    function updateStatus (message) {
        statusElement = document.getElementById('html2graph-status');
        statusElement.innerHTML = message;      
        statusElement.className = 'sent-message';
        setTimeout(function() {
            statusElement.className = '';            
        }, 1000);
    }

    function addElement (elementType, currentElement, content) { 
      // create a new  element 
      // and give it some content 
      var newElement = document.createElement(elementType); 
      var newContent = document.createTextNode(content); 
      newElement.appendChild(newContent); //add the text node to the newly created div. 

      // add the newly created element and its content into the DOM  
      currentElement.parentElement.insertBefore(newElement, currentElement.nextSibling); 
    }

    function doNoverlap(graphInstance) {
      // Configure the noverlap layout:
      var noverlapListener = graphInstance.configNoverlap({
        nodeMargin: 1,
        scaleNodes: 1.05,
        gridSize: 75,
        permittedExpansion: 2,
        easing: 'quadraticInOut', // animation transition function
        duration: 10000   // animation duration. Long here for the purposes of this example only
      });
      // Bind the events:
      noverlapListener.bind('start stop interpolate', function(e) {
        console.log('Noverlap: ' + e.type);
        updateStatus('Noverlap: ' + e.type);
        if(e.type === 'start') {
          console.time('noverlap');
        }
        if(e.type === 'interpolate') {
          console.timeEnd('noverlap');
        }
      });
      // Start the layout:
      graphInstance.startNoverlap();
    }

    // TODO: Fix this so it finds the HTML tag, specifically. Or the first tag with type 1? Maybe the HTML tag
    function createRoot(graphInstance, domNode) {
        if (typeof graphInstance.graph.nodes() !== 'undefined' && graphInstance.graph.nodes().length > 0) {
            console.log("Error creating root object");
            return;
        }

        rootId = (domNode.tagName || domNode.nodeName);

        graphInstance.graph.addNode({
            id: rootId,
            x: 0,
            y: 0,
            size: nodeSize,
            label: rootId + '-0',
            color: '#000'
        });
        // Start the ForceAtlas2 algorithm:
        graphInstance.startForceAtlas2(forceAtlas2Config);

        return rootId;
    }

    function addAnEdge(graphInstance, nodeA, nodeB) {
        graphInstance.killForceAtlas2();
        graphInstance.graph.addEdge({
            id: nodeA + nodeB,
            source: nodeA,
            target: nodeB
        });
        graphInstance.startForceAtlas2();
    }

    // TODO: Test and refactor
    function addNodesToEnd(graphInstance, maxNodes) {
        graphInstance.killForceAtlas2();
        
        allNodes = graphInstance.graph.nodes();
        nodeCount = allNodes.length;
        lastNode = allNodes[nodeCount - 1];
        nodeCount++;

        edgeCount = graphInstance.graph.edges().length;
        edgeCount++;

        graphInstance.graph.addNode({
            id: nodeIdPrefix + nodeCount,
            size: Math.random() * 5,
            x: lastNode.x * Math.cos(2 * 30 * Math.PI / nodeCount),
            y: lastNode.y * Math.sin(2 * 30 * Math.PI / nodeCount),
            color: "#000"
        });

        graphInstance.graph.addEdge({
            id: edgeIdPrefix + edgeCount,
            source: lastNode.id,
            target: nodeIdPrefix + nodeCount
        });
        graphInstance.startForceAtlas2();

        if (nodeCount > maxNodes) {
            clearInterval(nodeIntervalId);
            console.log('stopped adding nodes');
            graphInstance.killForceAtlas2();
            console.log('stopped force atlas');

        }

    }

    function recurseDomChildren(graphInstance, parent, parentNodeId) {
        var children;
        console.log(parent);

        if (parent.childNodes) {
            children = parent.childNodes;
            var child;

            //Still depth first, but I connect all children to the parent first
            //loop first, and connect all.
            //then loop again, pick one, and connect all of it's children
            //then ...
            // for (var i = 0; i < children.length; i++) {
                
            // }

            // This is a depth first visualization
            // The problem here is that the setTimeouts are set, then executed at the same time more or less. So this looks like a depth first... somehow. We actually need a signaling system where the last recursion signals the recursion before it to go... the the first call of the recursion stops everything.
            setTimeout(function() {
                for (var i = 0; i < children.length; i++) {

                    
                        child = children[i];
                        if (child.nodeType === 1) {
                            childNodeId = addNewChildNodeToParent(graphInstance, parent, parentNodeId, child);
                            if (child.childNodes) {
                                recurseDomChildren(graphInstance, child, childNodeId);
                            }
                        }              

                }
            }, stepTime*20);

        } 
    }

    function recurseBF(graphInstance, treeHeadNode) {
        rootId = createRoot(graphInstance, treeHeadNode);

        var stack = [{
            depth: 0,
            nodeId: rootId,
            element: treeHeadNode
        }];
        var stackItem = 0; //could use that too
        var current;
        var parent;
        var children, i, len;
        var depth; //not really used here, but keep
        var childNodeId;

        var nodeIntervalId = setInterval(function() {
            if (current = stack[stackItem++]) {
                if (!current.element.parentElement) {
                    console.log('Element with no parent: ' + (current.element.nodeName || current.element.tagName));
                }
                //console.log('popping next parent from stack');
                depth = current.depth;
                parent = current.element;
                parentNodeId = current.nodeId;
                children = parent.childNodes;

                //var childrenNodeIds = new Array();

                for (i = 0, len = children.length; i < len; i++) {
                    if (children[i].nodeType === 1) {
                        //console.log('adding child to stack');
                        childNodeId = addNewChildNodeToParent(graphInstance, parent, parentNodeId, children[i]);
                        stack.push({ //pass args via object or array
                            element: children[i],
                            nodeId: childNodeId,
                            depth: depth + 1
                        });
                        //childrenNodeIds.push(childNodeId);
                    }
                }

                // TODO: instead of edge, I just need a line drawn here.
                // for (var k = 0; k < childrenNodeIds.length - 1 ; k++) {
                //     addAnEdge(graphInstance, childrenNodeIds[k], childrenNodeIds[k + 1]);
                // }
                
            } else {
                clearInterval(nodeIntervalId);
                console.log('Finished adding nodes');
                updateStatus('Finished adding nodes');
                //give the graph some time to finish rendering
                setTimeout(function() {
                    graphInstance.killForceAtlas2();
                    console.log('Stopped ForceAtlas2');
                    updateStatus('Stopped ForceAtlas2');
                    //doNoverlap(graphInstance);
                }, finaleEaseTime);
            }

        }, stepTime);

    }

    // Should create a node, for every child, and create the edge between it and the parent
    function addNewChildNodeToParent(graphInstance, parent, parentNodeId, child) {

        graphInstance.killForceAtlas2();

        allNodes = graphInstance.graph.nodes();
        nodeCount = allNodes.length;
        nodeCount++;
        childNodeId = child.tagName + '-' + nodeCount;
        console.log(childNodeId);
        parentNode = graphInstance.graph.nodes(parentNodeId);

        graphInstance.graph.addNode({
            id: childNodeId,
            label: childNodeId,
            size: Math.random() * nodeSize,
            x: parentNode.x + (Math.random() * 2) * Math.cos(2 * 10 * Math.PI / Math.random()),
            y: parentNode.y + (Math.random() * 2) * Math.sin(2 * 10 * Math.PI / Math.random()),
            color: '#' + intToRGB(hashCode(child.tagName))
        });

        //console.log("connecting: " + parentNodeId + '->' + childNodeId);

        graphInstance.graph.addEdge({
            id: parentNodeId + '->' + childNodeId,
            source: parentNodeId,
            target: childNodeId
        });
        graphInstance.startForceAtlas2(forceAtlas2Config);

        return childNodeId;

    }

    function hashCode(str) { // java String#hashCode
        var hash = 0;
        for (var i = 0; i < str.length; i++) {
            hash = str.charCodeAt(i) + ((hash << 5) - hash);
        }
        return hash;
    }

    function intToRGB(i) {
        var c = (i & 0x00FFFFFF)
            .toString(16)
            .toUpperCase();

        return "00000".substring(0, 6 - c.length) + c;
    }

    function outputNode(node) {
        var whitespace = /^\s+$/g;
        if (node.nodeType === 1) {
            console.log("element: " + node.tagName);
        } else if (node.nodeType === 3) {
            //clear whitespace text nodes
            node.data = node.data.replace(whitespace, "");
            if (node.data) {
                //console.log("text: " + node.data); 
            }
        }
    }

    </script>
